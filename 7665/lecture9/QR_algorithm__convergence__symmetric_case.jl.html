<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/Documents/repositories/langou.github.io.git/7665/lecture9/QR_algorithm__convergence__symmetric_case.jl.html</title>
<meta name="Generator" content="Vim/9.1">
<meta name="plugin-version" content="vim9.0_v2">
<meta name="syntax" content="julia">
<meta name="settings" content="use_css,no_foldcolumn,pre_wrap,prevent_copy=,use_input_for_pc=none">
<meta name="colorscheme" content="morning">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #e4e4e4; }
body { font-family: monospace; color: #000000; background-color: #e4e4e4; }
* { font-size: 1em; }
a { color: inherit; }
.Statement { color: #a52a2a; font-weight: bold; }
.Comment { color: #0000ff; }
.Constant { color: #ff00ff; background-color: #eeeeee; padding-bottom: 1px; }
.Identifier { color: #008787; }
.Type { color: #2e8b57; font-weight: bold; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>

   <span class="Statement">using</span> LinearAlgebra
   <span class="Statement">using</span> Printf
   <span class="Statement">using</span> Random
   rng <span class="Statement">=</span> <span class="Type">MersenneTwister</span>()

   n <span class="Statement">=</span> <span class="Constant">8</span>
<span class="Comment">#</span><span class="Comment">  Λ = diagm(0 =&gt; Float32[2.0^(-i) for i=0:n-1])</span>
   Λ <span class="Statement">=</span> diagm(<span class="Constant">0</span> <span class="Statement">=&gt;</span> <span class="Type">Float32</span>[i <span class="Statement">for</span> i<span class="Statement">=</span><span class="Constant">1</span><span class="Statement">:</span>n])
   X <span class="Statement">=</span> rand(rng, n, n)
   X,_ <span class="Statement">=</span> qr(X)
   A <span class="Statement">=</span> <span class="Type">Symmetric</span>(X <span class="Statement">*</span> Λ <span class="Statement">*</span> X<span class="Statement">'</span>, <span class="Identifier">:L</span>)

   A0 <span class="Statement">=</span> copy(A)

   _, A0 <span class="Statement">=</span> hessenberg(A0)

   display(A0)
   A1 <span class="Statement">=</span> copy(A0)

<span class="Comment">#</span><span class="Comment"># feel welcome to &quot;warm up&quot; the symmetric tridiagonal matrix A so</span>
<span class="Comment">#</span><span class="Comment"># so that the smallest eigenvalue is placed in A[n,n] or not</span>

<span class="Comment">#</span><span class="Comment">  for i=1:5</span>
<span class="Comment">#</span><span class="Comment">  global A1, Q, R</span>
<span class="Comment">#</span><span class="Comment">  Q,R = qr(A1)</span>
<span class="Comment">#</span><span class="Comment">  A1 = SymTridiagonal(Symmetric(R*Q))</span>
<span class="Comment">#</span><span class="Comment">  end</span>
<span class="Comment">#</span><span class="Comment">  display(A1)</span>

   A2 <span class="Statement">=</span> copy(A1)
   <span class="Statement">for</span> i<span class="Statement">=</span><span class="Constant">1</span><span class="Statement">:</span><span class="Constant">4</span>
   <span class="Statement">global</span> s, B, Q, R, A2, tau, μ

<span class="Comment">#</span><span class="Comment"># this is a Rayleigh quotient shift </span>
<span class="Comment">#</span><span class="Comment"># it is possible that this shift does not lead to convergence</span>
<span class="Comment">#</span><span class="Comment"># see Trefethen and Bau p.222 for a discussion</span>
<span class="Comment">#</span><span class="Comment"># see Golub and Van Loan (4th edition) p.461 for a discussion</span>

<span class="Comment">#</span><span class="Comment">  μ = A2[n,n]</span>

<span class="Comment">#</span><span class="Comment"># this is the Wilkinson shift</span>
<span class="Comment">#</span><span class="Comment"># the Wilkinson shift is defined as that eigenvalue of the 2x2 bottom right block</span>
<span class="Comment">#</span><span class="Comment"># that is closer to A[n,n] </span>
<span class="Comment">#</span><span class="Comment"># see Trefethen and Bau p.222 for a discussion</span>
<span class="Comment">#</span><span class="Comment"># see Golub and Van Loan (4th edition) p.461 for a discussion</span>

   δ <span class="Statement">=</span> ( A2[n<span class="Statement">-</span><span class="Constant">1</span>,n<span class="Statement">-</span><span class="Constant">1</span>] <span class="Statement">-</span> A2[n,n] ) <span class="Statement">/</span> <span class="Constant">2</span>
   μ <span class="Statement">=</span> A2[n,n] <span class="Statement">-</span> sign( δ ) <span class="Statement">*</span> A2[n,n<span class="Statement">-</span><span class="Constant">1</span>]<span class="Statement">^</span><span class="Constant">2</span> <span class="Statement">/</span> ( abs( δ ) <span class="Statement">+</span> sqrt( δ<span class="Statement">^</span><span class="Constant">2</span> <span class="Statement">+</span> A2[n,n<span class="Statement">-</span><span class="Constant">1</span>]<span class="Statement">^</span><span class="Constant">2</span> ) )

<span class="Comment">#</span><span class="Comment"># choose how we want to do a step</span>
<span class="Comment">#</span><span class="Comment"># </span>
   case <span class="Statement">=</span> <span class="Constant">3</span>;

   <span class="Statement">if</span> ( case <span class="Statement">==</span> <span class="Constant">1</span> )

<span class="Comment">#</span><span class="Comment">#    EITHER case 1 :: a step of Schur iteration step (explicit shift)</span>
<span class="Comment">#</span><span class="Comment">#           no optimization done, this is brute force</span>

      B <span class="Statement">=</span> A2 <span class="Statement">-</span> μ <span class="Statement">*</span> <span class="Type">Matrix</span>{<span class="Type">Float64</span>}(I,n,n)
      Q,R <span class="Statement">=</span> qr(B)
      A2 <span class="Statement">=</span> Q<span class="Statement">'</span> <span class="Statement">*</span> A2 <span class="Statement">*</span> Q
      A2 <span class="Statement">=</span> <span class="Type">SymTridiagonal</span>(<span class="Type">Symmetric</span>( A2 ))

   <span class="Statement">elseif</span> ( case <span class="Statement">==</span> <span class="Constant">2</span> )

<span class="Comment">#</span><span class="Comment">#    OR     case 2 :: a step of QR iteration explicit shift </span>
<span class="Comment">#</span><span class="Comment">#           no optimization done, this is brute force</span>

      Q,R <span class="Statement">=</span> qr(A2 <span class="Statement">-</span> μ <span class="Statement">*</span> <span class="Type">Matrix</span>{<span class="Type">Float64</span>}(I,n,n))
      A2 <span class="Statement">=</span> R<span class="Statement">*</span>Q <span class="Statement">+</span> μ <span class="Statement">*</span> <span class="Type">Matrix</span>{<span class="Type">Float64</span>}(I,n,n)
      A2 <span class="Statement">=</span> <span class="Type">SymTridiagonal</span>(<span class="Type">Symmetric</span>( A2 ))

   <span class="Statement">elseif</span> ( case <span class="Statement">==</span> <span class="Constant">3</span> )

<span class="Comment">#</span><span class="Comment">#    OR     case 3 :: a step of QR iteration with implicit Q </span>
<span class="Comment">#</span><span class="Comment">#           no optimization done, this is brute force</span>

      B <span class="Statement">=</span> A2 <span class="Statement">-</span> μ <span class="Statement">*</span> <span class="Type">Matrix</span>{<span class="Type">Float64</span>}(I,n,n)
      b <span class="Statement">=</span> B[<span class="Constant">1</span><span class="Statement">:</span>n,<span class="Constant">1</span>]
      F <span class="Statement">=</span> qr(b)
      Q <span class="Statement">=</span> collect(F.Q)
      A2 <span class="Statement">=</span> Q<span class="Statement">*</span>A2<span class="Statement">*</span>Q<span class="Statement">'</span>
      A2 <span class="Statement">=</span> <span class="Type">Symmetric</span>( A2, <span class="Identifier">:L</span> )  <span class="Comment">#</span><span class="Comment"> it is critical to specify :L here, otherwise the tridiagonal</span>
      _, A2 <span class="Statement">=</span> hessenberg( A2 )  <span class="Comment">#</span><span class="Comment"> reduction algorithm called by &quot;hessenberg&quot; starts at the bottom</span>
      A2 <span class="Statement">=</span> <span class="Type">SymTridiagonal</span>(<span class="Type">Symmetric</span>( A2 ))

   <span class="Statement">end</span>

   display(A2)

   <span class="Statement">end</span>

;



</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
