<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/Documents/repositories/langou.github.io.git/7665/lecture9/implicitQ_demo_double.jl.html</title>
<meta name="Generator" content="Vim/9.1">
<meta name="plugin-version" content="vim9.0_v2">
<meta name="syntax" content="julia">
<meta name="settings" content="use_css,no_foldcolumn,pre_wrap,prevent_copy=,use_input_for_pc=none">
<meta name="colorscheme" content="morning">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #e4e4e4; }
body { font-family: monospace; color: #000000; background-color: #e4e4e4; }
* { font-size: 1em; }
a { color: inherit; }
.Statement { color: #a52a2a; font-weight: bold; }
.Comment { color: #0000ff; }
.Constant { color: #ff00ff; background-color: #eeeeee; padding-bottom: 1px; }
.Type { color: #2e8b57; font-weight: bold; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>

   <span class="Statement">using</span> LinearAlgebra
   <span class="Statement">using</span> Printf
   <span class="Statement">using</span> Random
   rng <span class="Statement">=</span> <span class="Type">MersenneTwister</span>()

   include(<span class="Constant">&quot;</span><span class="Constant">larfg.jl</span><span class="Constant">&quot;</span>)

<span class="Comment">#</span><span class="Comment">  the goal is to show that implicit single shift work</span>
<span class="Comment">#</span><span class="Comment">  we are not claiming that this is a good shift!</span>

   n <span class="Statement">=</span> <span class="Constant">8</span>
<span class="Comment">#</span><span class="Comment">  Λ = diagm(0 =&gt; Float32[2.0^(-i) for i=0:n-1])</span>
   Λ <span class="Statement">=</span> diagm(<span class="Constant">0</span> <span class="Statement">=&gt;</span> <span class="Type">Float32</span>[i <span class="Statement">for</span> i<span class="Statement">=</span><span class="Constant">1</span><span class="Statement">:</span>n])
   Λ[n<span class="Statement">-</span><span class="Constant">1</span><span class="Statement">:</span>n,n<span class="Statement">-</span><span class="Constant">1</span><span class="Statement">:</span>n] <span class="Statement">=</span> <span class="Constant">0.25</span><span class="Statement">*</span>[<span class="Constant">1.</span> <span class="Constant">2</span>;<span class="Statement">-</span><span class="Constant">2</span> <span class="Constant">1</span>]
   X <span class="Statement">=</span> rand(rng, n, n)
   A <span class="Statement">=</span> X <span class="Statement">*</span> Λ <span class="Statement">/</span> X
   A0 <span class="Statement">=</span> copy(A)
   A0, tau <span class="Statement">=</span> LAPACK.gehrd!(A0)
   A0 <span class="Statement">=</span> triu(A0,<span class="Statement">-</span><span class="Constant">1</span>)

<span class="Comment">#</span><span class="Comment">  let us do a double shift with</span>
<span class="Comment">#</span><span class="Comment">      A^2 - s * A + t * I</span>
   s <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">4</span>.
   t <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">3</span>.

<span class="Comment">#</span><span class="Comment"># step of Schur iteration step (no implicit Q)</span>
   A1 <span class="Statement">=</span> copy(A0)
   B <span class="Statement">=</span> A1<span class="Statement">^</span><span class="Constant">2</span> <span class="Statement">-</span> s <span class="Statement">*</span> A1 <span class="Statement">+</span> t <span class="Statement">*</span> <span class="Type">Matrix</span>{<span class="Type">Float64</span>}(I,n,n)
   Q,R <span class="Statement">=</span> qr(B)
   A1 <span class="Statement">=</span> Q<span class="Statement">'</span> <span class="Statement">*</span> A1 <span class="Statement">*</span> Q
<span class="Comment">#</span><span class="Comment"># Question: why is A1 upper Hessenberg?</span>
<span class="Comment">#</span><span class="Comment"># Not so easy to explain!</span>
<span class="Comment">#</span><span class="Comment">  display(A1)</span>
<span class="Comment">#</span><span class="Comment">  A1 = triu(A1,-1)</span>
<span class="Comment">#</span><span class="Comment">  display(A1)</span>
   display(UpperHessenberg(A1))

<span class="Comment">#</span><span class="Comment"># step of QR iteration with implicit shift </span>
   A2 <span class="Statement">=</span> copy(A0)
   B <span class="Statement">=</span> A0<span class="Statement">^</span><span class="Constant">2</span> <span class="Statement">-</span> s <span class="Statement">*</span> A0 <span class="Statement">+</span> t <span class="Statement">*</span> <span class="Type">Matrix</span>{<span class="Type">Float64</span>}(I,n,n)
   b <span class="Statement">=</span> B[<span class="Constant">1</span><span class="Statement">:</span>n,<span class="Constant">1</span>]
   F <span class="Statement">=</span> qr(b)
   Q <span class="Statement">=</span> collect(F.Q)  <span class="Comment">#</span><span class="Comment"> you really want the full Q here</span>
   Q2, H2 <span class="Statement">=</span> hessenberg( Q<span class="Statement">*</span>A2<span class="Statement">*</span>Q<span class="Statement">'</span> )
   display(H2)

<span class="Comment">#</span><span class="Comment"># an &quot;optimized&quot; implementation - step 1 - compute only the first column and in a smart way</span>
   A2 <span class="Statement">=</span> copy(A0)
   v <span class="Statement">=</span> zeros(n,<span class="Constant">1</span>);
   v[<span class="Constant">1</span><span class="Statement">:</span><span class="Constant">3</span>] <span class="Statement">=</span> [ A0[<span class="Constant">1</span>,<span class="Constant">1</span>]<span class="Statement">*</span>A0[<span class="Constant">1</span>,<span class="Constant">1</span>] <span class="Statement">+</span> A0[<span class="Constant">1</span>,<span class="Constant">2</span>]<span class="Statement">*</span>A0[<span class="Constant">2</span>,<span class="Constant">1</span>] <span class="Statement">-</span> s<span class="Statement">*</span>A0[<span class="Constant">1</span>,<span class="Constant">1</span>] <span class="Statement">+</span> t;
         A0[<span class="Constant">2</span>,<span class="Constant">1</span>]<span class="Statement">*</span>(A0[<span class="Constant">1</span>,<span class="Constant">1</span>]<span class="Statement">+</span>A0[<span class="Constant">2</span>,<span class="Constant">2</span>]<span class="Statement">-</span>s);
         A0[<span class="Constant">2</span>,<span class="Constant">1</span>]<span class="Statement">*</span>A0[<span class="Constant">3</span>,<span class="Constant">2</span>] ]

   τ <span class="Statement">=</span> larfg!(v)

   v[<span class="Constant">1</span>] <span class="Statement">=</span> <span class="Constant">1.0</span>

<span class="Comment">#</span><span class="Comment">  A2 = (I(n) - v * τ * v' ) * A2 * (I(n) - v * τ * v' )</span>

<span class="Comment">#</span><span class="Comment">  A2 = A2 - v * τ * ( v' * A2 )</span>
<span class="Comment">#</span><span class="Comment">  A2 = A2 - ( A2 * v ) * τ * v'</span>

   A2 <span class="Statement">.-=</span> v <span class="Statement">*</span> τ <span class="Statement">*</span> ( v<span class="Statement">'</span> <span class="Statement">*</span> A2 )
   A2 <span class="Statement">.-=</span> ( A2 <span class="Statement">*</span> v ) <span class="Statement">*</span> τ <span class="Statement">*</span> v<span class="Statement">'</span>

   Q2, H2 <span class="Statement">=</span> hessenberg( A2 )
   display(H2)


<span class="Comment">#</span><span class="Comment"># an &quot;optimized&quot; implementation - step 2 - v is of size 3</span>

   A2 <span class="Statement">=</span> copy(A0)
   v <span class="Statement">=</span> [ A0[<span class="Constant">1</span>,<span class="Constant">1</span>]<span class="Statement">*</span>A0[<span class="Constant">1</span>,<span class="Constant">1</span>] <span class="Statement">+</span> A0[<span class="Constant">1</span>,<span class="Constant">2</span>]<span class="Statement">*</span>A0[<span class="Constant">2</span>,<span class="Constant">1</span>] <span class="Statement">-</span> s<span class="Statement">*</span>A0[<span class="Constant">1</span>,<span class="Constant">1</span>] <span class="Statement">+</span> t;
         A0[<span class="Constant">2</span>,<span class="Constant">1</span>]<span class="Statement">*</span>(A0[<span class="Constant">1</span>,<span class="Constant">1</span>]<span class="Statement">+</span>A0[<span class="Constant">2</span>,<span class="Constant">2</span>]<span class="Statement">-</span>s);
         A0[<span class="Constant">2</span>,<span class="Constant">1</span>]<span class="Statement">*</span>A0[<span class="Constant">3</span>,<span class="Constant">2</span>] ]

   τ <span class="Statement">=</span> larfg!(v)

   v[<span class="Constant">1</span>] <span class="Statement">=</span> <span class="Constant">1.0</span>

   A2[<span class="Constant">1</span><span class="Statement">:</span><span class="Constant">3</span>,<span class="Constant">1</span><span class="Statement">:</span>n]<span class="Statement">.-=</span> v <span class="Statement">*</span> τ <span class="Statement">*</span> ( v<span class="Statement">'</span> <span class="Statement">*</span> A2[<span class="Constant">1</span><span class="Statement">:</span><span class="Constant">3</span>,<span class="Constant">1</span><span class="Statement">:</span>n] )
   A2[<span class="Constant">1</span><span class="Statement">:</span>n,<span class="Constant">1</span><span class="Statement">:</span><span class="Constant">3</span>]<span class="Statement">.-=</span> ( A2[<span class="Constant">1</span><span class="Statement">:</span>n,<span class="Constant">1</span><span class="Statement">:</span><span class="Constant">3</span>] <span class="Statement">*</span> v ) <span class="Statement">*</span> τ <span class="Statement">*</span> v<span class="Statement">'</span>

   Q2, H2 <span class="Statement">=</span> hessenberg( A2 )
   display(H2)

;

<span class="Comment">#</span><span class="Comment"># an &quot;optimized&quot; implementation - step 3 - recognize that A2 is Hessenberg with </span>
<span class="Comment">#</span><span class="Comment"># a bulge so we can O(n^2) bulge chasing algorithm to compute H2</span>

<span class="Comment">#</span><span class="Comment">### =&gt; see code gees.jl</span>

;


<span class="Comment">#</span><span class="Comment"># Question: why is A1 upper Hessenberg?</span>
<span class="Comment">#</span><span class="Comment"># Not so easy to explain!</span>

<span class="Comment">#</span><span class="Comment">  Either we say that a polynomial of degree 2 can be factored in two polynomials</span>
<span class="Comment">#</span><span class="Comment">  of degree 1. Or we do as follows</span>

<span class="Comment">#</span><span class="Comment">  B = A1 - 3. I</span>
<span class="Comment">#</span><span class="Comment">  Q,R = qr(B)</span>
<span class="Comment">#</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; QR = A - 3I</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; R  = Q'( A - 3 I )</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; RQ = Q'( A - 3 I )Q</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; RQ = Q' A Q - 3 I</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; Q' A Q = RQ + 3 I</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; this explains Hessenberg structure of Q' A Q </span>

<span class="Comment">#</span><span class="Comment">  B = A1^2 + 4 A1 - 3 I </span>
<span class="Comment">#</span><span class="Comment">  Q,R = qr(B)</span>
<span class="Comment">#</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; QR = A1^2 + 4 A1 - 3 I</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; R  = Q' A1^2 + 4 Q' A1 - 3 I</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; RQ = ( Q' A1 Q )^2 + 4 Q' A1 Q - 3 I</span>
<span class="Comment">#</span><span class="Comment">  ==&gt; since RQ is 2-Hessenberg, it must be that Q' A1 Q is Hessenberg</span>
<span class="Comment">#</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
